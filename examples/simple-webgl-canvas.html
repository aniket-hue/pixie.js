<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebGL Infinite Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2a2a2a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background: #f5f5f5;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .controls div {
            margin: 5px 0;
        }
        
        .camera-info {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>WebGL Infinite Canvas</h3>
        <div><strong>Pan:</strong> Click and drag</div>
        <div><strong>Zoom:</strong> Mouse wheel</div>
        <div><strong>Reset:</strong> Double-click</div>
        <div class="camera-info">
            Camera: <span id="camera-info">x:0 y:0 zoom:1.0</span>
        </div>
    </div>
    
    <canvas id="webgl-canvas"></canvas>
    
    <script>
        class SimpleWebGLRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.initGL();
                this.createShaders();
                this.setupInput();
                this.resize();
                
                // Handle window resize
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            initGL() {
                const gl = this.gl;
                
                // Enable blending for transparency
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                // Create position buffer
                this.positionBuffer = gl.createBuffer();
            }
            
            createShaders() {
                const gl = this.gl;
                
                // Vertex shader - transforms vertices and applies camera
                const vertexSource = `
                    attribute vec2 a_position;
                    uniform vec2 u_resolution;
                    uniform vec2 u_camera_translation;
                    uniform float u_camera_zoom;
                    
                    void main() {
                        // Apply camera transformation to vertex
                        vec2 cameraPos = (a_position + u_camera_translation) * u_camera_zoom;
                        
                        // Convert to normalized device coordinates (-1 to +1)
                        vec2 clipSpace = ((cameraPos / u_resolution) * 2.0) - 1.0;
                        
                        // WebGL coordinate system has Y pointing up, but screen has Y pointing down
                        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                    }
                `;
                
                // Fragment shader - determines pixel color
                const fragmentSource = `
                    precision mediump float;
                    uniform vec4 u_color;
                    
                    void main() {
                        gl_FragColor = u_color;
                    }
                `;
                
                // Compile shaders
                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                // Create and link program
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    throw new Error('Program linking failed: ' + gl.getProgramInfoLog(this.program));
                }
                
                // Get uniform and attribute locations
                this.locations = {
                    position: gl.getAttribLocation(this.program, 'a_position'),
                    resolution: gl.getUniformLocation(this.program, 'u_resolution'),
                    cameraTranslation: gl.getUniformLocation(this.program, 'u_camera_translation'),
                    cameraZoom: gl.getUniformLocation(this.program, 'u_camera_zoom'),
                    color: gl.getUniformLocation(this.program, 'u_color')
                };
            }
            
            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error('Shader compilation failed: ' + error);
                }
                
                return shader;
            }
            
            setupInput() {
                let isDragging = false;
                let lastPos = { x: 0, y: 0 };
                
                // Mouse/touch events for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastPos = { x: e.clientX, y: e.clientY };
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - lastPos.x;
                    const deltaY = e.clientY - lastPos.y;
                    
                    // Pan camera (adjust for zoom level)
                    this.camera.x += deltaX / this.camera.zoom;
                    this.camera.y -= deltaY / this.camera.zoom; // Flip Y for natural feel
                    
                    lastPos = { x: e.clientX, y: e.clientY };
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                // Zoom with mouse wheel
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Get world position of mouse before zoom
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    
                    // Apply zoom
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.camera.zoom = Math.max(0.1, Math.min(5, this.camera.zoom * zoomFactor));
                    
                    // Get world position of mouse after zoom
                    const newWorldPos = this.screenToWorld(mouseX, mouseY);
                    
                    // Adjust camera to keep mouse position fixed
                    this.camera.x += worldPos.x - newWorldPos.x;
                    this.camera.y += worldPos.y - newWorldPos.y;
                });
                
                // Reset camera on double-click
                this.canvas.addEventListener('dblclick', () => {
                    this.camera = { x: 0, y: 0, zoom: 1 };
                });
            }
            
            screenToWorld(screenX, screenY) {
                // Convert screen coordinates to world coordinates
                const ndcX = (screenX / this.canvas.width) * 2 - 1;
                const ndcY = -((screenY / this.canvas.height) * 2 - 1);
                
                const worldX = (ndcX * this.canvas.width / 2) / this.camera.zoom - this.camera.x;
                const worldY = (ndcY * this.canvas.height / 2) / this.camera.zoom - this.camera.y;
                
                return { x: worldX, y: worldY };
            }
            
            clear(r = 0.96, g = 0.96, b = 0.96, a = 1) {
                const gl = this.gl;
                gl.clearColor(r, g, b, a);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            
            setupForDrawing() {
                const gl = this.gl;
                
                gl.useProgram(this.program);
                
                // Set uniforms that don't change per object
                gl.uniform2f(this.locations.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.locations.cameraTranslation, this.camera.x, this.camera.y);
                gl.uniform1f(this.locations.cameraZoom, this.camera.zoom);
                
                // Setup position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.enableVertexAttribArray(this.locations.position);
                gl.vertexAttribPointer(this.locations.position, 2, gl.FLOAT, false, 0, 0);
            }
            
            drawRectangle(x, y, width, height, color = [0.2, 0.4, 0.8, 1]) {
                const gl = this.gl;
                
                // Rectangle vertices (two triangles)
                const vertices = new Float32Array([
                    x, y,                    // Triangle 1
                    x + width, y,
                    x, y + height,
                    x, y + height,           // Triangle 2
                    x + width, y,
                    x + width, y + height
                ]);
                
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                gl.uniform4f(this.locations.color, ...color);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            
            drawLine(x1, y1, x2, y2, color = [0.3, 0.3, 0.3, 1]) {
                const gl = this.gl;
                
                const vertices = new Float32Array([x1, y1, x2, y2]);
                
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                gl.uniform4f(this.locations.color, ...color);
                gl.drawArrays(gl.LINES, 0, 2);
            }
            
            drawCircle(centerX, centerY, radius, color = [0.8, 0.2, 0.2, 1], segments = 32) {
                const gl = this.gl;
                const vertices = [];
                
                // Create circle using triangle fan
                for (let i = 0; i < segments; i++) {
                    const angle1 = (i / segments) * Math.PI * 2;
                    const angle2 = ((i + 1) / segments) * Math.PI * 2;
                    
                    // Triangle from center
                    vertices.push(centerX, centerY);
                    vertices.push(centerX + Math.cos(angle1) * radius, centerY + Math.sin(angle1) * radius);
                    vertices.push(centerX + Math.cos(angle2) * radius, centerY + Math.sin(angle2) * radius);
                }
                
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.uniform4f(this.locations.color, ...color);
                gl.drawArrays(gl.TRIANGLES, 0, segments * 3);
            }
        }
        
        // Initialize the renderer
        const canvas = document.getElementById('webgl-canvas');
        const renderer = new SimpleWebGLRenderer(canvas);
        
        // Generate some random objects for demonstration
        const objects = [];
        for (let i = 0; i < 100; i++) {
            objects.push({
                type: Math.random() > 0.7 ? 'circle' : 'rectangle',
                x: (Math.random() - 0.5) * 2000,
                y: (Math.random() - 0.5) * 2000,
                width: 30 + Math.random() * 70,
                height: 30 + Math.random() * 70,
                radius: 15 + Math.random() * 35,
                color: [Math.random() * 0.8 + 0.2, Math.random() * 0.8 + 0.2, Math.random() * 0.8 + 0.2, 0.8]
            });
        }
        
        // Animation loop
        function animate() {
            // Clear canvas
            renderer.clear();
            
            // Setup WebGL state for drawing
            renderer.setupForDrawing();
            
            // Draw grid
            const gridSize = 100;
            const extent = 3000;
            const gridColor = [0.85, 0.85, 0.85, 1];
            
            for (let x = -extent; x <= extent; x += gridSize) {
                renderer.drawLine(x, -extent, x, extent, gridColor);
            }
            for (let y = -extent; y <= extent; y += gridSize) {
                renderer.drawLine(-extent, y, extent, y, gridColor);
            }
            
            // Draw origin axes
            renderer.drawLine(-extent, 0, extent, 0, [0.7, 0.7, 0.7, 1]);
            renderer.drawLine(0, -extent, 0, extent, [0.7, 0.7, 0.7, 1]);
            
            // Draw objects
            objects.forEach(obj => {
                if (obj.type === 'circle') {
                    renderer.drawCircle(obj.x, obj.y, obj.radius, obj.color);
                } else {
                    renderer.drawRectangle(obj.x, obj.y, obj.width, obj.height, obj.color);
                }
            });
            
            // Update camera info display
            const cameraInfo = document.getElementById('camera-info');
            const cam = renderer.camera;
            cameraInfo.textContent = `x:${cam.x.toFixed(0)} y:${cam.y.toFixed(0)} zoom:${cam.zoom.toFixed(2)}`;
            
            requestAnimationFrame(animate);
        }
        
        // Start the animation loop
        animate();
        
        console.log('WebGL Infinite Canvas initialized!');
        console.log('- Pan by clicking and dragging');
        console.log('- Zoom with mouse wheel');
        console.log('- Double-click to reset camera');
    </script>
</body>
</html>
